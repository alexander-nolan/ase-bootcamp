### Part 5: Testing and Troubleshooting  

#### 9. Testing the Application (45 minutes)  

##### **Step 1: Verify Service Availability**  

1. **Angular Front-End**  
   - Open your browser and navigate to `http://localhost:4200`.  
   - Ensure the Angular application loads correctly.  

2. **ExpressJS Server**  

   1. We changed the compose file to use a random NodePort for scaling. To find out the port, run the following: 

     ```bash
     docker ps 
     ```

     Replace <NODE_PORT> with the port from the command above.

   2. Open and visit:  
     ```bash  
     http://localhost:<NODE_PORT>/api/grades
     ```

   3. Verify that the response contains the generated text.  

3. **Flask API**  

   - In VSCode Open a Git Bash terminal and run:
     
     ```bash  
     curl http://localhost:5000/api/generate -X POST -H "Content-Type: application/json" -d '{"query": "Hello"}'  
     ```
     
   - Verify that the response contains the generated text.  

4. **SQLite Database**  
   - Ensure that data is being stored in the `database/data.db` file. You can use an SQLite client or command line tool to check the contents of the database.  

##### **Step 2: End-to-End Testing**  

1. **Submit a Query via Angular Front-End**  
   - In the Angular application, enter a query in the input field and click the "Generate Response" button.  
   - Verify that the response is displayed on the page.  
   
2. **Check Data Persistence**  
   - Verify that the query and generated response are stored in the SQLite database.  
      - First, you need to find the ID or name of the running ExpressJS container. You can do this by running:
        ```bash
            docker ps
        ```
      - Use the docker exec command to open a terminal in the running container. Replace <container_id_or_name> with the actual container ID or name you found in the previous step:
        ```bash
            docker exec -it <container_id_or_name> sh
        ```
      - Once you are inside the container, you can run a query to check the contents of the `grades` table. Assuming the database is in the database directory inside the container:
         ```sql  
            sqlite3 database/data.db "SELECT * FROM grades;"  
        ```

    
   
##### **Step 3: Load Testing**  

1. **Simulate Multiple Requests**  
   - Use a tool like `Apache JMeter`, `Artillery`, or `locust` to simulate multiple users interacting with the application.  
   - Monitor the application’s performance and ensure it can handle the load.  
   
#### 10. Troubleshooting (45 minutes)  

##### **Step 1: Common Issues and Resolutions**  

1. **Container Not Starting**  
   - Check the logs of the container to identify the issue:  
     ```bash  
     docker logs <container_id>  
     ```
   - Ensure that all dependencies are correctly specified in the `Dockerfile`.  
   
2. **Service Not Accessible**  
   - Verify that the service is running and accessible via the specified ports.  
   - Ensure that the service is correctly defined in the `docker-compose.yml` file and that the ports are correctly mapped.  
   
3. **Database Connection Issues**  
   - Ensure the database service is running and accessible.  
   - Verify the connection string and ensure that the database file exists and is correctly mapped.  
   
4. **Inter-Container Communication Issues**  
   - Ensure that the services can communicate with each other using the service names as hostnames.  
   - Verify that the network is correctly defined in the `docker-compose.yml` file.  
   
##### **Step 2: Debugging Techniques**  

1. **Using Docker Exec**  
   - Run commands inside a running container to debug issues:  
     ```bash  
     docker exec -it <container_id> /bin/sh  
     ```
   
2. **Inspecting Docker Networks**  
   - Verify the network configuration and connectivity between containers:  
     ```bash  
     docker network inspect <network_name>  
     ```
   
3. **Checking Resource Usage**  
   - Monitor the resource usage of containers to identify performance bottlenecks:  
     ```bash  
     docker stats  
     ```
   
4. **Reviewing Application Logs**  
   - Check the logs generated by the application to identify errors and issues.  
   
##### **Step 3: Applying Fixes and Retesting**  

1. **Apply Necessary Fixes**  
   - Based on the troubleshooting steps, apply the necessary fixes to the application code, Dockerfiles, or `docker-compose.yml`.  
   
2. **Rebuild and Restart Services**  
   - Rebuild the affected services:  
     ```bash  
     docker-compose build <service_name>  
     ```
   - Restart the services:  
     ```bash  
     docker-compose up -d <service_name>  
     ```
   
3. **Retest the Application**  
   - Repeat the testing steps to ensure that the fixes have resolved the issues.  
   
### Final Verification  

1. **Verify Application Functionality**  
   - Ensure that all components of the application are functioning as expected.  
   - Perform end-to-end testing to verify the application’s overall functionality.  
   
2. **Verify Data Persistence**  
   - Ensure that the data is correctly stored and retrieved from the SQLite database.  
   
3. **Verify Performance and Scalability**  
   - Ensure that the application can handle the expected load and scale as needed.  
   
### Conclusion  

Congratulations on completing the lab. You have gained hands-on experience in building and managing a multi-container application using Docker and Docker Compose. You learned to apply best practices for Docker image optimization, container orchestration, and troubleshooting in production environments. This lab exercise provides a comprehensive understanding of Docker and its ecosystem, preparing participants for deploying and managing containerized applications in real-world scenarios.